# ROS Services

The goal of this module is to build a package with a service server and a simple service client to connect and interface with it.

## Milestone 0: Set up workshop

Build and run the module. (On Powershell, just use the run with `embedml/ros-humble-workshop:module-7` like in past modules.)

## Milestone 1: Inspect Structure

Look at the `/root` directory contents. HINT: Remember this command from the earlier modules?

Should look something like this
```
.
├── service_client.py
└── workspace_folder
```

The `workspace_folder` has the common folder structure generated by `colcon build` Within the source folder of the workspace are two packages.

```
workspace_folder/src/
├── custom_service
└── service_py
```

Take a few moments and look at what each one contains. One package defines a service file `.srv` and the other provides the ROS Service server implemented in Python.

Looking back at the `/root` directory, notice there is also a standalone Python file labeled as `service_client.py`

In making this module, I kinda went down a rabbit hole tangential to my senior design project and made a service that runs a multilateration package. The actual results are garbage, but I just wanted to interface with a ROS2 Service for something a bit more complex than the standard "add_two_ints" examples. If you want to debug it, then I recommend passing the workspace as a volume to the container (HINT: remember `docker run -v...`?) so you can edit the file more easily. You will likely want to mount the folder into a different directory in the `/root` directory of the container because there is already a static copy of the workspace with the original name there.

Now, open that `service_client.py` Python file in the container and scroll through its contents.

Notice in particular the following line in `main()`:

```python
future = position_client.send_request()
rclpy.spin_until_future_complete(position_client, future)
response = future.result()
```

Services support asynchronous calls where the call is non-blocking and does not halt code execution to await a result, so here, we are explicitly telling the interpreter to wait for the result.

Also, how many requests will this code send?

## Milestone 2: Using Services

First, source the workspace overlay. Otherwise, the next section may fail silently.

Run the service server called `service_server` in package `service_py`. No output is to be expected. It should just be waiting for a client request.

Now, lets open another terminal into the container and run the client.

```bash
python service_client.py
```

In the client terminal, you should see two log messages back-to-back. First is the real position of the simulated multilateration target, and second is the result from the service.

On the server terminal, it should show something about the "Geolocation" it is performing each time it is called by the client.

## Extras

I have personally found services very useful for serial port management in ROS. The service server manages all the communication with a serial device and formats the data in both directions to standardize communication. In general, service servers are a nice way to contain a repetitive action with a limited-access system resource. When working in Docker, you can expose TCP ports on your root machine to the container and have two-way networking with your ROS system and some host-system process. One way to do manage this neatly is again to use a service.
